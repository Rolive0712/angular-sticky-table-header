// Generated by CoffeeScript 1.7.1
describe('angular-sticky-table-header', function() {
  var $window, options;
  options = {
    cloneClassName: 'sticky-clone',
    stuckClassName: 'sticky-stuck',
    interval: 10
  };
  window._ = {
    debounce: function(fn) {
      return fn;
    },
    throttle: function(fn) {
      return fn;
    }
  };
  $window = {
    scrollY: 0,
    on: function() {},
    off: function() {}
  };
  beforeEach(module('stickyTableHeader'), function($provide) {
    $provide.value('options', options);
    $provide.value('$window', $window);
    return null;
  });
  beforeEach(function() {
    return inject((function(_this) {
      return function($compile, $rootScope) {
        _this.scope = $rootScope.$new();
        angular.extend(_this.scope, {
          columnCollection: ['foo', 'bar', 'baz'],
          rowCollection: (Array.apply(null, Array(200))).map(function() {
            return ['moo', 'woo', 'zoo'];
          })
        });
        _this.element = angular.element("<div sticky-table-header columns=\"columnCollection\" rows=\"rowCollection\">\n\n	<table class=\"table\">\n		<thead>\n			<tr>\n				<th ng-repeat=\"th in columnCollection\">{{th}}</th>\n			</tr>\n		</thead>\n		<tbody>\n			<tr ng-repeat=\"tr in rowCollection\">\n				<td ng-repeat=\"td in tr\">{{td}}</td>\n			</tr>\n		</tbody>\n	</table>\n\n</div>");
        ($compile(_this.element))(_this.scope);
        _this.scope.$digest();
        return $window = {
          scrollY: 0,
          on: function() {},
          off: function() {}
        };
      };
    })(this));
  });
  describe('#createClone', function() {
    it('should clone the first <tr> it finds and append it to the <thead>', function() {
      expect((this.element.find('thead tr')).length).toBe(1);
      this.scope.createClone();
      return expect((this.element.find('thead tr')).length).toBe(2);
    });
    it('should clone the <tr>\'s contents', function() {
      this.scope.createClone();
      return expect(($((this.element.find('thead tr'))[1]).find('th')).length).toBe(this.scope.columnCollection.length);
    });
    it('should clone the <tr>\'s events', function() {
      var clone, mock;
      mock = {
        fn: function() {}
      };
      spyOn(mock, 'fn');
      $((this.element.find('thead tr'))[0]).find('th').on('click', mock.fn);
      clone = this.scope.createClone();
      $((this.element.find('thead tr'))[1]).find('th').click();
      return expect(mock.fn).toHaveBeenCalled();
    });
    it('should mirror the original <tr>\'s className', function() {
      this.element.find('thead tr').addClass('test');
      this.scope.createClone();
      return expect($((this.element.find('thead tr'))[1]).hasClass('test')).toBe(true);
    });
    return it('should assign the clone the className defined in options.cloneClassName', function() {
      this.scope.createClone();
      return expect($((this.element.find('thead tr'))[1]).hasClass(options.cloneClassName)).toBe(true);
    });
  });
  describe('#resetClone', function() {
    it('should call #removeClones, #createClone, and #sizeClone', function() {
      spyOn(this.scope, 'removeClones');
      spyOn(this.scope, 'createClone');
      spyOn(this.scope, 'sizeClone');
      this.scope.resetClone();
      expect(this.scope.removeClones).toHaveBeenCalled();
      expect(this.scope.createClone).toHaveBeenCalled();
      return expect(this.scope.sizeClone).toHaveBeenCalled();
    });
    return it('should set scope.clone to the value returned by #createClone', function() {
      this.scope.clone = null;
      this.scope.removeClones = function() {};
      this.scope.createClone = function() {
        return 42;
      };
      this.scope.sizeClone = function() {};
      this.scope.resetClone();
      return expect(this.scope.clone).toBe(42);
    });
  });
  describe('#removeClones', function() {
    it('should set scope.isStuck to false', function() {
      this.scope.createClone();
      this.scope.removeClones();
      return expect(this.scope.isStuck).toBe(false);
    });
    return it('should remove all <tr> clones', function() {
      this.scope.createClone();
      this.scope.createClone();
      this.scope.createClone();
      expect((this.element.find('.' + options.cloneClassName)).length).toBe(3);
      this.scope.removeClones();
      return expect((this.element.find('.' + options.cloneClassName)).length).toBe(0);
    });
  });
  describe('#setCloneGutter', function() {
    return it('should set the <th> clone\'s left and right CSS equal to scope.offset', function() {
      this.scope.clone = {
        css: function() {}
      };
      this.scope.offset = {
        left: 1,
        right: 2
      };
      spyOn(this.scope.clone, 'css');
      this.scope.setCloneGutter();
      return expect(this.scope.clone.css).toHaveBeenCalledWith(this.scope.offset);
    });
  });
  describe('#setOffset', function() {
    it('should call getBoundingClientRect on the first <tr>', function() {
      spyOn((this.element.find('tr'))[0], 'getBoundingClientRect');
      this.scope.setOffset();
      return expect((this.element.find('tr'))[0].getBoundingClientRect).toHaveBeenCalled();
    });
    return it('should set scope.offset equal to the value returned by getBoundingClientRect', function() {
      this.scope.offset = null;
      spyOn((this.element.find('tr'))[0], 'getBoundingClientRect').andReturn('foo');
      this.scope.setOffset();
      return expect(this.scope.offset).toEqual('foo');
    });
  });
  describe('#setStuck', function() {
    it('should set scope.isStuck equal to the boolean passed into it', function() {
      this.scope.isStuck = null;
      this.scope.setStuck(true);
      return expect(this.scope.isStuck).toBe(true);
    });
    return it('should coerce non-boolean values into booleans', function() {
      this.scope.setStuck(true);
      expect(this.scope.isStuck).toBe(true);
      this.scope.setStuck('foo');
      expect(this.scope.isStuck).toBe(true);
      this.scope.setStuck(42);
      expect(this.scope.isStuck).toBe(true);
      this.scope.setStuck(null);
      expect(this.scope.isStuck).toBe(false);
      this.scope.setStuck(0);
      expect(this.scope.isStuck).toBe(false);
      this.scope.setStuck(false);
      return expect(this.scope.isStuck).toBe(false);
    });
  });
  describe('#toggleClone', function() {
    it('should toggle options.stuckClassName on the clone', function() {
      this.scope.clone = {
        addClass: function() {},
        removeClass: function() {}
      };
      spyOn(this.scope.clone, 'addClass');
      spyOn(this.scope.clone, 'removeClass');
      this.scope.toggleClone(true);
      expect(this.scope.clone.addClass).toHaveBeenCalledWith(options.stuckClassName);
      this.scope.toggleClone(false);
      return expect(this.scope.clone.removeClass).toHaveBeenCalledWith(options.stuckClassName);
    });
    return it('should coerce non-boolean values into booleans', function() {
      this.scope.clone = {
        addClass: function() {},
        removeClass: function() {}
      };
      spyOn(this.scope.clone, 'addClass');
      spyOn(this.scope.clone, 'removeClass');
      this.scope.toggleClone(1);
      expect(this.scope.clone.addClass).toHaveBeenCalledWith(options.stuckClassName);
      this.scope.toggleClone(0);
      return expect(this.scope.clone.removeClass).toHaveBeenCalledWith(options.stuckClassName);
    });
  });
  describe('#sizeClone', function() {
    return it('should call #setOffset, #setClonedCellWidths, and #setClonedCellWidths', function() {
      this.scope.clone = true;
      this.scope.setClonedCellWidths = function() {};
      this.scope.setCloneGutter = function() {};
      this.scope.setOffset = function() {};
      spyOn(this.scope, 'setClonedCellWidths');
      spyOn(this.scope, 'setCloneGutter');
      spyOn(this.scope, 'setOffset');
      this.scope.sizeClone();
      expect(this.scope.setOffset).toHaveBeenCalled();
      expect(this.scope.setClonedCellWidths).toHaveBeenCalled();
      return expect(this.scope.setCloneGutter).toHaveBeenCalled();
    });
  });
  describe('#checkScroll', function() {
    beforeEach(function() {
      spyOn(this.scope, 'setStuck');
      return spyOn(this.scope, 'setClonedCellWidths').andCallFake(function() {});
    });
    it('should call #setStuck with true and #setClonedCellWidths with no arguments when scope.isStuck is false and scrollY is >= offset.top', function() {
      this.scope.clone = true;
      this.scope.isStuck = false;
      this.scope.offset = {
        top: 0
      };
      $window.scrollY = 1;
      this.scope.checkScroll();
      expect(this.scope.setStuck).toHaveBeenCalledWith(true);
      return expect(this.scope.setClonedCellWidths).toHaveBeenCalled();
    });
    it('should call #setStuck with false when scope.isStuck is true and scrollY is < offset.top', function() {
      this.scope.clone = true;
      this.scope.isStuck = true;
      this.scope.offset = {
        top: 1
      };
      $window.scrollY = 0;
      this.scope.checkScroll();
      return expect(this.scope.setStuck).toHaveBeenCalledWith(false);
    });
    return it('should not call #setStuck otherwise', function() {
      this.scope.clone = true;
      this.scope.isStuck = true;
      this.scope.offset = {
        top: 0
      };
      $window.scrollY = 1;
      this.scope.checkScroll();
      this.scope.isStuck = false;
      this.scope.offset = {
        top: 1
      };
      $window.scrollY = 0;
      this.scope.checkScroll();
      return expect(this.scope.setStuck).not.toHaveBeenCalled();
    });
  });
  return describe('$destroy', function() {
    return it('should remove the mutation observer', function() {
      this.scope.mutationObserver = function() {};
      spyOn(this.scope, 'mutationObserver');
      this.scope.$destroy();
      return expect(this.scope.mutationObserver).toHaveBeenCalled();
    });
  });
});
